from abc import ABC, abstractmethod
from dataclasses import dataclass
from pathlib import Path
import shutil
import os
import io
import contextlib
from typing import Callable, List


@dataclass
class TestRunResult:
    returncode: int
    stdout: str
    stderr: str


class TestRunner(ABC):
    """Base class for system test runners.

    This class provides a common interface for running system tests on LOBSTER tools.
    The following features are provided:
    - The test runner can be configured with input files that are copied into the
      working directory before running the tool.
    - The test runner can be configured with output files that are expected to be
      generated by the tool. These files can be checked after the tool has been run.
    - The test runner can be configured with command line arguments that are passed
      to the tool when it is run.
    - The test runner can be configured with a working directory that is used as the
      current working directory when the tool is run.
    - The test runner can run the tool under test and return the result as a
      subprocess.CompletedProcess object.
    """

    def __init__(self, tool_main_fnc: Callable, working_dir: Path):
        """Constructor

        :param tool_main_fnc: main function that is also specified in setup.py as the
            tool's entry point (see variable 'console_scripts' there)
        :param working_dir: path to a directory which to use as current working
        directory for the tool under test. Input files will be copied into this
        directory before running the tool.
        """
        if not isinstance(tool_main_fnc, Callable):
            raise TypeError("Invalid Test Setup: tool_main_fnc must be callable")
        self._tool_main_fnc = tool_main_fnc
        self._tool_output_files: List[Path] = []
        self._working_dir = working_dir

    @property
    def tool_output_files(self) -> List[Path]:
        """Returns a list of output files that are expected to be generated by the tool.

        The TestRunner expects that the output files are generated in the working
        directory. However, the return value of this method is a list of Path objects
        pointing to the files which serve as comparison reference. It is then possible
        to check if one file has been generated for each file in the list.
        """
        return self._tool_output_files

    @property
    def working_dir(self) -> Path:
        """Returns the directory that is used as the current working directory
        when the tool under test is run.
        """
        return self._working_dir

    @abstractmethod
    def get_tool_args(self) -> List[str]:
        """Returns the command line arguments that shall be used to start the tool under
           test."""
        pass

    def declare_input_file(self, file: Path):
        """
        Declares a file from the 'data' folder to be used as an input file.
        This file will be copied into the execution directory immediately.
        """
        self.copy_file_to_working_directory(file)

    def declare_output_file(self, file: Path):
        self._tool_output_files.append(file)

    def copy_file_to_working_directory(self, file: Path):
        """
        Declares a file from the 'data' folder to be used as an input file.
        This file will be copied into the execution directory immediately.
        """
        shutil.copy(
            src=file,
            dst=self._working_dir,
        )

    def declare_inputs_from_file(self, file: Path, data_directory: Path):
        """
        Copies files and directories listed in a file to the working directory.
        Args:
            file: Path to a text file containing relative paths (one per line)
                  to input files or directories.

            data_directory: Base directory to resolve the relative paths listed
                            in the file.
        Behavior:
            - For each line in the input file, constructs the full path by joining
              `data_directory` with the line.
            - If the resolved path is a file, copies it to the working directory.
            - If the resolved path is a directory, then it copies the whole directory
              into the working directory.
        """

        self.copy_file_to_working_directory(file)
        with open(file, "r", encoding="UTF-8") as fd:
            for line in fd:
                input_path = data_directory / line.strip()
                if input_path.is_file():
                    self.copy_file_to_working_directory(input_path)
                elif input_path.is_dir():
                    shutil.copytree(
                        input_path,
                        self._working_dir / input_path.name,
                        dirs_exist_ok=True
                    )

    @staticmethod
    def get_repo_root() -> Path:
        """Returns the root directory of the LOBSTER repository."""
        return Path(__file__).resolve().parents[1]

    def run_tool_test(self) -> TestRunResult:
        """Runs the tool under test"""
        stdout_buffer = io.StringIO()
        stderr_buffer = io.StringIO()
        old_cwd = Path.cwd()
        rv = None
        try:
            # Change to designated working directory
            os.chdir(self._working_dir)
            with contextlib.redirect_stdout(stdout_buffer), \
                    contextlib.redirect_stderr(stderr_buffer):
                rv = self._tool_main_fnc(*self.get_tool_args())
        finally:
            # Restore original working directory
            os.chdir(old_cwd)
        return TestRunResult(
            returncode=rv,
            stdout=stdout_buffer.getvalue(),
            stderr=stderr_buffer.getvalue(),
        )
