#!/usr/bin/env python3
#
# lobster_json - Extract JSON tags for LOBSTER
# Copyright (C) 2023 Bayerische Motoren Werke Aktiengesellschaft (BMW AG)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public
# License along with this program. If not, see
# <https://www.gnu.org/licenses/>.

import os
import argparse
import json


def fetch_values(filename, data, name):
    chain = name.split(".")

    ptr = data
    current = []
    for attr in chain[:-1]:
        current.append(attr)
        if attr in ptr:
            ptr = ptr[attr]
        else:
            print("%s: error: object does not contain %s" %
                  (filename, ".".join(current)))
            return None
        if not isinstance(ptr, dict):
            print("%s: error: %s is not an object" %
                  (filename, ".".join("current")))
            return None

    if chain[-1] not in ptr:
        print("%s: error: object does not contain attribute %s" %
              (filename, chain[-1]))
        return None

    ptr = ptr[chain[-1]]
    tags = []
    if isinstance(ptr, list):
        for tag in ptr:
            if isinstance(tag, str):
                tags.append(tag)
            elif isinstance(tag, int):
                tags.append(str(tag))
            else:
                print("%s: error: tag %s is neither string nor integer" %
                      (filename, tag))
    elif isinstance(ptr, str):
        tags.append(ptr)
    elif isinstance(ptr, int):
        tags.append(str(ptr))
    else:
        print("%s: error: tag %s is neither string nor integer" %
              (filename, tag))

    return tags


def process_dict(db, filename, data,
                 tag_attr,
                 name_attr,
                 include_path_in_name,
                 sequence):
    assert isinstance(sequence, int) or sequence is None

    if name_attr is not None:
        name = fetch_values(filename, data, name_attr)
        if not name:
            return
        elif len(name) != 1:
            print("%s: error: only a single name can be given (%s)" %
                  (filename, " or ".join(name)))
        name = name[0]

    else:
        # Make a name based on filename
        if not include_path_in_name:
            base = os.path.basename(filename)
        else:
            base = filename
        base = base.replace("\\", "/").strip("./").replace(".json", "")
        parts = base.replace(" ", "_").split("/")
        name = ".".join(parts)
        if sequence is not None:
            name += "_%u" % sequence

    tags = fetch_values(filename, data, tag_attr)
    if tags is None:
        return

    if name in db:
        print("%s: error: duplicate object %s" % (filename, name))
        return

    db[name] = {"kind"      : "test",
                "framework" : "custom json file",
                "source"    : {"ref"     : "file",
                               "precise" : False,
                               "file"    : os.path.relpath(filename)},
                "tags"      : tags}


def process(db, filename, tag_attr, name_attr, include_path_in_name):
    assert isinstance(db, dict)
    assert os.path.isfile(filename)
    assert isinstance(tag_attr, str)
    assert isinstance(name_attr, str) or name_attr is None
    assert isinstance(include_path_in_name, bool)

    with open(filename, "r", encoding="UTF-8") as fd:
        data = json.load(fd)

    if isinstance(data, dict):
        process_dict(db, filename, data,
                     tag_attr,
                     name_attr,
                     include_path_in_name,
                     None)
    elif isinstance(data, list):
        for n, item in enumerate(data):
            process_dict(db, filename, item,
                         tag_attr,
                         name_attr,
                         include_path_in_name,
                         n)
    else:
        print("%s: error: top level value is not an array or object" %
              filename)


def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--tag-attribute",
                    help="attribute indicating the tag(s) of the top-level json object",
                    required=True)
    ap.add_argument("--name-attribute",
                    help="attribute indicating the name of the activity")
    ap.add_argument("--include-path-in-name",
                    help="when synthesising names, include the total path",
                    default=False,
                    action="store_true")
    ap.add_argument("--out",
                    help="write to this file instead of stdout")
    ap.add_argument("paths",
                    metavar="FILE|DIR",
                    nargs="+",
                    help="process these files or directories")

    options = ap.parse_args()

    db = {}

    for path in options.paths:
        if os.path.isfile(path):
            process(db, path,
                    options.tag_attribute,
                    options.name_attribute,
                    options.include_path_in_name)
        elif os.path.isdir(path):
            for prefix, _, files in os.walk(path):
                for filename in files:
                    if filename.endswith(".json"):
                        process(db,
                                os.path.join(prefix, filename),
                                options.tag_attribute,
                                options.name_attribute,
                                options.include_path_in_name)
        else:
            ap.error("%s is not a file or directory" % path)

    output = {"data"      : db,
              "generator" : "lobster_json",
              "schema"    : "lobster-act-trace",
              "version"   : 1}

    if options.out:
        with open(options.out, "w") as fd:
            json.dump(output, fd, indent=2)
    else:
        print(json.dumps(output, indent=2))


if __name__ == "__main__":
    main()
