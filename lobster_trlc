#!/usr/bin/env python3
#
# lobster_trlc - Extract TRLC requirements for LOBSTER
# Copyright (C) 2022-2023 Bayerische Motoren Werke Aktiengesellschaft (BMW AG)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public
# License along with this program. If not, see
# <https://www.gnu.org/licenses/>.

import sys
import argparse
import os.path

from trlc.errors import Message_Handler, TRLC_Error
from trlc.trlc import Source_Manager
from trlc.ast import Package

from lobster.location import File_Reference
from lobster.items import Tracing_Tag, Requirement
from lobster.io import lobster_write


def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("files",
                    nargs="+",
                    metavar="FILE|DIR")
    ap.add_argument("--out",
                    default=None)
    ap.add_argument("--descriptions",
                    nargs="+",
                    default=["text"],
                    metavar="TRLC attribute name")
    ap.add_argument("--cb-tags",
                    nargs="+",
                    default=[],
                    metavar="TRLC attribute name")

    options = ap.parse_args()

    mh = Message_Handler()
    sm = Source_Manager(mh)

    try:
        for name in options.files:
            if os.path.isfile(name):
                sm.register_file(name)
            elif os.path.isdir(name):
                sm.register_directory(name)
            else:
                ap.error("%s is not a file or directory" % name)
        stab = sm.process()
    except TRLC_Error:
        return 1

    if stab is None:
        return 1

    items = []

    for pkg in stab.table.values():
        if not isinstance(pkg, Package):
            continue
        for obj in pkg.symbols.iter_record_objects():
            py_obj = obj.to_python_dict()
            text = []
            for attr_name in options.descriptions:
                if attr_name not in py_obj:
                    continue
                if isinstance(py_obj[attr_name], str):
                    text.append(py_obj[attr_name])
                elif isinstance(py_obj[attr_name], list):
                    for text_item in py_obj[attr_name]:
                        text.append(text_item)
            if text:
                text = "\n".join(text)
            else:
                text = None

            loc = File_Reference(filename = obj.location.file_name,
                                 line     = obj.location.line_no,
                                 column   = obj.location.col_no)
            tag = Tracing_Tag(namespace = "req",
                              tag       = pkg.name + "." + obj.name)
            item = Requirement(
                tag       = tag,
                location  = loc,
                framework = "TRLC",
                kind      = obj.e_typ.name,
                name      = pkg.name + " " + obj.name.replace("_", " "),
                text      = text)

            for tagname in options.cb_tags:
                if tagname in py_obj and py_obj[tagname]:
                    tag = Tracing_Tag(namespace = "req",
                                      tag       = str(py_obj[tagname]),
                                      version   = None)
                    item.add_tracing_target(tag)

            items.append(item)

    if options.out:
        with open(options.out, "w", encoding="UTF-8") as fd:
            lobster_write(fd, Requirement, "lobster_trlc", items)
        print("Written output for %u items to %s" % (len(items),
                                                     options.out))
    else:
        lobster_write(sys.stdout, Requirement, "lobster_trlc", items)


if __name__ == "__main__":
    sys.exit(main())
